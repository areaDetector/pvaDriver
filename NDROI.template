# Database for ND ROIs
# Mark Rivers
# April 22, 2008

###################################################################
#  These records control the connection of the server to          #
#  an NDArray port and address                                    #
###################################################################
# NDArray port name
record(stringout, "$(P)$(R)NDArrayPort")
{
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDARRAY_PORT")
}

record(stringin, "$(P)$(R)NDArrayPort_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)NDArrayAddress")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDArray_ADDR")
}

record(longin, "$(P)$(R)NDArrayAddress_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDArray_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether this ROI is used                 #
###################################################################
record(mbbo, "$(P)$(R)Use")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))USE")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
}

record(mbbi, "$(P)$(R)Use_RBV")
{
#   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))USE")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the ROI definition                       #
#  including binning, region start and size                       # 
###################################################################

record(longout, "$(P)$(R)BinX")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_BIN")
}

record(longin, "$(P)$(R)BinX_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)BinY")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_BIN")
}

record(longin, "$(P)$(R)BinY_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_BIN")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)MinX")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_MIN")
}

record(longin, "$(P)$(R)MinX_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)MinY")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_MIN")
}

record(longin, "$(P)$(R)MinY_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_MIN")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)SizeX")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_SIZE")
}

record(longin, "$(P)$(R)SizeX_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_SIZE")
   field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)SizeY")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_SIZE")
}

record(longin, "$(P)$(R)SizeY_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_SIZE")
   field(SCAN, "I/O Intr")
}

record(mbbo, "$(P)$(R)ReverseX")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_REVERSE")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
}

record(mbbi, "$(P)$(R)ReverseX_RBV")
{
#   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM0_REVERSE")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

record(mbbo, "$(P)$(R)ReverseY")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_REVERSE")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
}

record(mbbi, "$(P)$(R)ReverseY_RBV")
{
#   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DIM1_REVERSE")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ImageSizeX_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(R)ImageSizeY_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_SIZE_Y")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether statistics are computed          #
###################################################################
record(mbbo, "$(P)$(R)ComputeStats")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))COMPUTE_STATS")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
}

record(mbbi, "$(P)$(R)ComputeStats_RBV")
{
#   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))COMPUTE_STATS")
   field(ZRST, "No")
   field(ZRVL, "0")
   field(ONST, "Yes")
   field(ONVL, "1")
   field(SCAN, "I/O Intr")
}


###################################################################
#  These records control the minimum time between ROI updates     #
###################################################################

record(ao, "$(P)$(R)MinTime")
{
    field(PINI, "1")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_UPDATE_TIME")
    field(VAL,  "0.0")
    field(EGU,  "s")
    field(PREC, "3")
}

record(ai, "$(P)$(R)MinTime_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_UPDATE_TIME")
    field(VAL,  "1.0")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(mbbo, "$(P)$(R)BlockingCallbacks")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BLOCKING_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
}

# Array posting flag
record(mbbi, "$(P)$(R)BlockingCallbacks_RBV")
{
#    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BLOCKING_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}


###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "$(P)$(R)ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_COUNTER")
}

record(longin, "$(P)$(R)ArrayCounter_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# This record needs work, because B should reflect the time since last processed
record(calc, "$(P)$(R)ArrayRate_RBV")
{
    field(INPA, "$(P)$(R)ArrayRate_RBV.B NPP NMS")  # Previous counter value
    field(INPB, "$(P)$(R)ArrayCounter_RBV NPP NMS") # Current counter value
    field(INPC, "1.0")                              # Delta time, needs work
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}

record(longout, "$(P)$(R)DroppedArrays")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DROPPED_ARRAYS")
}

record(longin, "$(P)$(R)DroppedArrays_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"$(P)$(R)AsynIO")
{
    field(PORT, $(PORT))
    field(TIB2,"1")
}

