# Database for NDPluginBase, i.e. records common to all plugins
# Mark Rivers
# April 25, 2008

###################################################################
#  These records control the connection of the server to          #
#  an NDArray driver port and address                             #
###################################################################
# Array port name
record(stringout, "$(P)$(R)NDArrayPort")
{
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDARRAY_PORT")
}

record(stringin, "$(P)$(R)NDArrayPort_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDARRAY_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(R)NDArrayAddress")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDARRAY_ADDR")
}

record(longin, "$(P)$(R)NDArrayAddress_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NDARRAY_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks are enabled and        #
#  minimum time between callbacks                                 #
###################################################################
record(mbbo, "$(P)$(R)EnableCallbacks")
{
    field(PINI, "1")
    field(VAL,  "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ENABLE_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
}

record(mbbi, "$(P)$(R)EnableCallbacks_RBV")
{
#    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ENABLE_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}

record(ao, "$(P)$(R)MinCallbackTime")
{
    field(PINI, "1")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MIN_CALLBACK_TIME")
    field(VAL,  "1.0")
    field(EGU,  "s")
    field(PREC, "3")
}

record(ai, "$(P)$(R)MinCallbackTime_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))MIN_CALLBACK_TIME")
    field(VAL,  "1.0")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(mbbo, "$(P)$(R)BlockingCallbacks")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BLOCKING_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
}

# Array posting flag
record(mbbi, "$(P)$(R)BlockingCallbacks_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BLOCKING_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}


###################################################################
#  These records provide statistics on array callbacks and        #
#  array callback rates                                           # 
###################################################################
record(longout, "$(P)$(R)ArrayCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_COUNTER")
}

record(longin, "$(P)$(R)ArrayCounter_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))ARRAY_COUNTER")
    field(SCAN, "I/O Intr")
}

# This record needs work, because B should reflect the time since last processed
record(calc, "$(P)$(R)ArrayRate_RBV")
{
    field(INPA, "$(P)$(R)ArrayRate_RBV.B NPP NMS")  # Previous counter value
    field(INPB, "$(P)$(R)ArrayCounter_RBV NPP NMS") # Current counter value
    field(INPC, "1.0")                              # Delta time, needs work
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}

record(longout, "$(P)$(R)DroppedArrays")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DROPPED_ARRAYS")
}

record(longin, "$(P)$(R)DroppedArrays_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DROPPED_ARRAYS")
    field(SCAN, "I/O Intr")
}

###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"$(P)$(R)AsynIO")
{
    field(PORT, $(PORT))
    field(TIB2,"1")
}

