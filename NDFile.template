# Database for ADFile driver, which saves files for area detector data.
# Mark Rivers
# April 7, 2008

###################################################################
#  These records control the connection of the server to          #
#  an image port and address                                      #
###################################################################
# Image port name
record(stringout, "$(P)$(F)ImagePort")
{
    field(DTYP, "asynOctetWrite")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_PORT")
}

record(stringin, "$(P)$(F)ImagePort_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_PORT")
    field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(F)ImageAddress")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_ADDR")
}

record(longin, "$(P)$(F)ImageAddress_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_ADDR")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control the minimum time between file writes     #
###################################################################

record(ao, "$(P)$(F)MinWriteTime")
{
    field(PINI, "1")
    field(DTYP, "asynFloat64")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_MIN_TIME")
    field(VAL,  "0.0")
    field(EGU,  "s")
    field(PREC, "3")
}

record(ai, "$(P)$(F)MinWriteTime_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynFloat64")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_MIN_TIME")
    field(VAL,  "1.0")
    field(EGU,  "s")
    field(PREC, "3")
    field(SCAN, "I/O Intr")
}

###################################################################
#  These records control whether callbacks block or not           #
###################################################################
record(mbbo, "$(P)$(F)BlockingCallbacks")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BLOCKING_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
}

# Image posting flag
record(mbbi, "$(P)$(F)BlockingCallbacks_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))BLOCKING_CALLBACKS")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}


###################################################################
#  These records are the image size and data type                 #
###################################################################
record(longin, "$(P)$(F)ImageSizeX_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_SIZE_X")
   field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(F)ImageSizeY_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_SIZE_Y")
   field(SCAN, "I/O Intr")
}

record(mbbi, "$(P)$(F)DataType_RBV")
{
   field(PINI, "1")
   field(DTYP, "asynInt32")
   field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DATA_TYPE")
   field(ZRST, "Int8")
   field(ZRVL, "0")
   field(ONST, "UInt8")
   field(ONVL, "1")
   field(TWST, "Int16")
   field(TWVL, "2")
   field(THST, "UInt16")
   field(THVL, "3")
   field(FRST, "Int32")
   field(FRVL, "4")
   field(FVST, "UInt32")
   field(FVVL, "5")
   field(SXST, "Float32")
   field(SXVL, "6")
   field(SVST, "Float64")
   field(SVVL, "7")
   field(SCAN, "I/O Intr")
}

###################################################################
#  These records provide statistics on image callbacks and        #
#  image callback rates                                           # 
###################################################################
record(longout, "$(P)$(F)ImageCounter")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_COUNTER")
}

record(longin, "$(P)$(F)ImageCounter_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))IMAGE_COUNTER")
    field(SCAN, "I/O Intr")
}

# This record needs work, because B should reflect the time since last processed
record(calc, "$(P)$(F)ImageRate_RBV")
{
    field(INPA, "$(P)$(F)ImageRate_RBV.B NPP NMS")  # Previous counter value
    field(INPB, "$(P)$(F)ImageCounter_RBV NPP NMS") # Current counter value
    field(INPC, "1.0")                              # Delta time, needs work
    field(CALC, "(B-A)/C")
    field(PREC, "1")
    field(SCAN, "1 second")
}

record(longout, "$(P)$(F)DroppedImages")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DROPPED_IMAGES")
}

record(longin, "$(P)$(F)DroppedImages_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))DROPPED_IMAGES")
    field(SCAN, "I/O Intr")
}


###################################################################
#  The asynRecord is used for mainly for trace mask               # 
###################################################################
 
# Set ASYN_TRACEIO_HEX bit by default
record(asyn,"$(P)$(F)AsynIO")
{
    field(PORT, $(PORT))
    field(TIB2,"1")
}

###################################################################
#  These records control file I/O                                 # 
###################################################################

# File path.
record(waveform, "$(P)$(F)FilePath")
{
    field(PINI, "1")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_PATH")
    field(FTVL, "UCHAR")
    field(NELM, "256")
}

record(waveform, "$(P)$(F)FilePath_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_PATH")
    field(FTVL, "UCHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# Filename
record(waveform, "$(P)$(F)FileName")
{
    field(PINI, "1")
    field(DTYP, "asynOctetWrite")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_NAME")
    field(FTVL, "UCHAR")
    field(NELM, "256")
}

record(waveform, "$(P)$(F)FileName_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_NAME")
    field(FTVL, "UCHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# File number
record(longout, "$(P)$(F)FileNumber")
{
    field(PINI, "1")
    field(VAL,  "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_NUMBER")
}

record(longin, "$(P)$(F)FileNumber_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_NUMBER")
    field(SCAN, "I/O Intr")
}

record(calcout, "$(P)$(F)FileNumber_Sync")
{
    field(INPA, "$(P)$(F)FileNumber_RBV CP")
    field(CALC, "A")
    field(OUT,  "$(P)$(F)FileNumber PP")
}

# Autoincrement flag
record(mbbo, "$(P)$(F)AutoIncrement")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))AUTO_INCREMENT")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
}

record(mbbo, "$(P)$(F)AutoIncrement_RBV")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))AUTO_INCREMENT")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}

# File template
record(waveform, "$(P)$(F)FileTemplate")
{
    field(PINI,  "1")
    field(DTYP, "asynOctetWrite")
    field(INP,   "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_TEMPLATE")
    field(FTVL, "UCHAR")
    field(NELM, "256")
}

record(waveform, "$(P)$(F)FileTemplate_RBV")
{
    field(PINI,  "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_TEMPLATE")
    field(FTVL, "UCHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# Full filename, including path
record(waveform, "$(P)$(F)FullFileName_RBV")
{
    field(PINI,  "1")
    field(DTYP, "asynOctetRead")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FULL_FILE_NAME")
    field(FTVL, "UCHAR")
    field(NELM, "256")
    field(SCAN, "I/O Intr")
}

# Autosave flag
record(mbbo, "$(P)$(F)AutoSave")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))AUTO_SAVE")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
}

record(mbbi, "$(P)$(F)AutoSave_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))AUTO_SAVE")
    field(ZRST, "No")
    field(ZRVL, "0")
    field(ONST, "Yes")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}

# NOTE: These should be busy records, but wait till we get asynBusy record
# Write file
record(longout, "$(P)$(F)WriteFile")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))WRITE_FILE")
}

# Read file
record(longout, "$(P)$(F)ReadFile")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))READ_FILE")
}

# File data format 
record(mbbo, "$(P)$(F)FileFormat")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_FORMAT")
    field(ZRST, "netCDF")
    field(ZRVL, "0")
    field(ONST, "Invalid")
    field(ONVL, "1")
}

record(mbbi, "$(P)$(F)FileFormat_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))FILE_FORMAT")
    field(ZRST, "netCDF")
    field(ZRVL, "0")
    field(ONST, "Invalid")
    field(ONVL, "1")
    field(SCAN, "I/O Intr")
}

# File save mode 
record(mbbo, "$(P)$(F)FileWriteMode")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))WRITE_MODE")
    field(ZRST, "Single")
    field(ZRVL, "0")
    field(ONST, "Capture")
    field(ONVL, "1")
    field(TWST, "Stream")
    field(TWVL, "2")
}

record(mbbi, "$(P)$(F)FileWriteMode_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))WRITE_MODE")
    field(ZRST, "Single")
    field(ZRVL, "0")
    field(ONST, "Capture")
    field(ONVL, "1")
    field(TWST, "Stream")
    field(TWVL, "2")
    field(SCAN, "I/O Intr")
}

# NOTE: These should be busy records, and no RBV, but wait till we get asynBusy record
# Capture data
record(longout, "$(P)$(F)Capture")
{
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))CAPTURE")
}

record(longin, "$(P)$(F)Capture_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))CAPTURE")
    field(SCAN, "I/O Intr")
}

record(longout, "$(P)$(F)NumCapture")
{
    field(PINI, "1")
    field(VAL,  "1")
    field(DTYP, "asynInt32")
    field(OUT,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NUM_CAPTURE")
}

record(longin, "$(P)$(F)NumCapture_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NUM_CAPTURE")
    field(SCAN, "I/O Intr")
}

record(longin, "$(P)$(F)NumCaptured_RBV")
{
    field(PINI, "1")
    field(DTYP, "asynInt32")
    field(INP,  "@asyn($(PORT),$(ADDR),$(TIMEOUT))NUM_CAPTURED")
    field(SCAN, "I/O Intr")
}


